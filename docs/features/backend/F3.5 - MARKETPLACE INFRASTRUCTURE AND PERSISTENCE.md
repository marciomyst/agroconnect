# üß± F3.5 ‚Äî Marketplace Backend Infrastructure & Persistence

## üéØ Objetivo

Implementar toda a **infraestrutura de persist√™ncia do Marketplace (F3.x)** no backend, garantindo que os aggregates de dom√≠nio j√° existentes (Product, SellerProduct e PurchaseIntent) possam ser **armazenados, consultados e versionados corretamente** no banco de dados.

Esta feature **n√£o exp√µe endpoints HTTP** e **n√£o inclui l√≥gica de API**, focando exclusivamente em **EF Core, migrations, reposit√≥rios e DI**.

---

## üß† Contexto

Ap√≥s a implementa√ß√£o da F3.x no **Domain** e **Application**, o backend ainda n√£o possui:

* Mapeamento EF Core dos novos aggregates
* Tabelas no banco de dados
* Reposit√≥rios concretos
* Read repositories para queries de Marketplace e Purchase Intents

A F3.5 prepara o terreno t√©cnico para que as pr√≥ximas features (API e Frontend) possam operar com seguran√ßa.

---

## üì¶ Escopo

### üìå DbContext

Atualizar `AgronomiaDbContext` para incluir:

* `DbSet<Product> Products`
* `DbSet<SellerProduct> SellerProducts`
* `DbSet<PurchaseIntent> PurchaseIntents`

Garantir que:

* `ApplyConfigurationsFromAssembly` continue funcionando corretamente
* Domain events permane√ßam ignorados pelo EF

---

### üìå EF Core Configurations

Criar configura√ß√µes expl√≠citas em
`Agronomia.Infrastructure.Persistence.Configurations`:

#### `ProductConfiguration`

* Tabela: `products`
* Chave prim√°ria: `ProductId`
* Mapear:

  * `Name`
  * `Category` (string)
  * `UnitOfMeasure` (string)
  * `RegistrationNumber` (nullable)
  * `IsControlledByRecipe`
  * `IsActive`
  * `CreatedAtUtc`
* √çndices:

  * `Name`
  * `(Name, RegistrationNumber)` (unique quando aplic√°vel)

---

#### `SellerProductConfiguration`

* Tabela: `seller_products`
* Chave prim√°ria: `SellerProductId`
* Mapear:

  * `SellerId`
  * `ProductId`
  * `Price.Amount`
  * `Price.Currency` (BRL)
  * `IsAvailable`
  * `CreatedAtUtc`
  * `UpdatedAtUtc`
* Restri√ß√µes:

  * Unique index em `(SellerId, ProductId)`
* FKs:

  * `SellerId ‚Üí sellers`
  * `ProductId ‚Üí products`

---

#### `PurchaseIntentConfiguration`

* Tabela: `purchase_intents`
* Chave prim√°ria: `PurchaseIntentId`
* Mapear:

  * `FarmId`
  * `SellerId`
  * `ProductId`
  * `SellerProductId`
  * `Quantity`
  * `Notes`
  * `Status` (string)
  * `RequestedAtUtc`
  * `UpdatedAtUtc`
* √çndices:

  * `FarmId`
  * `SellerId`
  * `Status`
  * `RequestedAtUtc`

---

### üìå Reposit√≥rios Concretos

Implementar em
`Agronomia.Infrastructure.Persistence.Repositories`:

* `EfSellerProductRepository`
* `EfPurchaseIntentRepository`

Com suporte a:

* `AddAsync`
* `GetByIdAsync`
* Atualiza√ß√£o de status
* Expira√ß√£o de inten√ß√µes pendentes

---

### üìå Read Repositories

Implementar em
`Agronomia.Infrastructure.Persistence.ReadRepositories`:

* `MarketplaceReadRepository`

  * Implementa `IMarketplaceReadRepository`
  * Queries otimizadas (EF ou Dapper)
* `PurchaseIntentReadRepository`

  * Implementa `IPurchaseIntentReadRepository`
  * Leitura por Farm e por Seller

Todas as queries devem ser:

* `AsNoTracking`
* Projetadas diretamente para DTOs

---

### üìå Dependency Injection

Atualizar o registro de servi√ßos para incluir:

* Reposit√≥rios F3.x
* Read repositories F3.x

Sem alterar registros existentes.

---

### üìå Migrations

Criar migrations EF Core para:

* `products`
* `seller_products`
* `purchase_intents`

Nome sugerido:

* `F3_5_MarketplaceInfrastructure`

---

## üö´ Fora de Escopo

* Endpoints HTTP
* Controllers / Minimal APIs
* Regras de autoriza√ß√£o
* Frontend
* Jobs de background
* Testes automatizados

---

## ‚úÖ Crit√©rios de Aceite

* DbContext compila com os novos DbSets
* Configura√ß√µes EF corretamente aplicadas
* Migrations geradas e aplic√°veis sem erro
* Reposit√≥rios concretos resolvidos via DI
* Nenhuma quebra em F0.x, F1.x ou F2.x
* Backend inicializa corretamente ap√≥s migration