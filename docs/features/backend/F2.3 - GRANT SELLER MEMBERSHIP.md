Perfeito. Abaixo estÃ¡ o **documento normativo do F2.3 â€” GrantSellerMembership**, **no mesmo formato, rigor e nÃ­vel de detalhe** dos F2.1 e F2.2, respeitando integralmente:

* Linguagem UbÃ­qua â€” AgroConnect
* DOMAIN_EVENTS.md
* ARCHITECTURE.md
* ROADMAP.md

Sem criar conceitos, eventos ou atalhos.

---

## ðŸŽ¯ Objetivo do F2.3 â€” GrantSellerMembership

Criar a **feature de concessÃ£o de Membership em Seller**, responsÃ¡vel por:

* Conceder a um **User existente** um papel dentro de uma **Seller existente**
* Criar um novo **SellerMembership**
* Garantir que apenas papÃ©is vÃ¡lidos sejam atribuÃ­dos
* Disparar o evento de domÃ­nio **SellerMembershipGranted**
* Respeitar regras de autorizaÃ§Ã£o baseadas em Membership

Sem:

* criar Seller
* criar User
* alterar autenticaÃ§Ã£o
* criar eventos novos
* violar CQRS ou Clean Architecture

---

## ðŸ“ Estrutura de pastas / namespaces

### Domain

Em `AgroConnect.Domain`:

```text
AgroConnect.Domain
 â””â”€â”€ Memberships
     â”œâ”€â”€ SellerMembership.cs
     â””â”€â”€ SellerRole.cs
```

> O Aggregate `SellerMembership` **jÃ¡ existe** (criado no F2.1).
> O F2.3 **reutiliza** o mesmo Aggregate e o mesmo enum `SellerRole`.

---

### Application

Em `AgroConnect.Application`:

```text
AgroConnect.Application
 â””â”€â”€ Features
     â””â”€â”€ Sellers
         â””â”€â”€ GrantSellerMembership
             â”œâ”€â”€ GrantSellerMembershipCommand.cs
             â”œâ”€â”€ GrantSellerMembershipResult.cs
             â”œâ”€â”€ GrantSellerMembershipHandler.cs
             â””â”€â”€ GrantSellerMembershipValidator.cs
```

---

### Api

Em `AgroConnect.Api`:

```text
AgroConnect.Api
 â””â”€â”€ Features
     â””â”€â”€ Sellers
         â””â”€â”€ GrantSellerMembership
             â”œâ”€â”€ GrantSellerMembershipEndpoint.cs
             â””â”€â”€ GrantSellerMembershipHttpRequest.cs
```

---

## 1. Aggregate `SellerMembership` (reutilizado)

### 1.1. Objetivo

Representar o **vÃ­nculo entre um User e uma Seller**, com um papel especÃ­fico.

---

### 1.2. Responsabilidades (no F2.3)

* Criar um novo vÃ­nculo User â†” Seller
* Garantir papel vÃ¡lido (`SellerRole`)
* Disparar `SellerMembershipGranted`

---

### 1.3. Regras importantes

* Um `SellerMembership` representa **um Ãºnico papel**
* Um User pode ter **mÃºltiplos Memberships** na mesma Seller (se o domÃ­nio permitir no futuro)
* A verificaÃ§Ã£o de duplicidade (ex.: mesmo User + Seller + Role) Ã© responsabilidade do **Application Layer**
* Aggregate **nÃ£o referencia** `Seller` nem `User` diretamente (apenas IDs)

---

## 2. Command `GrantSellerMembership`

### 2.1. Objetivo

Expressar a **intenÃ§Ã£o de conceder um papel de Seller a um User**.

---

### 2.2. Dados carregados

* `SellerId`
* `UserId`
* `Role` (`SellerRole`)

---

### 2.3. Assinatura conceitual

```text
GrantSellerMembershipCommand
```

Retorna:

```text
GrantSellerMembershipResult
```

---

## 3. Handler `GrantSellerMembershipHandler`

### 3.1. Responsabilidade

Orquestrar a concessÃ£o de Membership garantindo **autorizaÃ§Ã£o, consistÃªncia e atomicidade**.

---

### 3.2. Fluxo lÃ³gico

1. Validar Command
2. Garantir que a **Seller existe**
3. Garantir que o **User existe**
4. Garantir que o **User executor**:

   * possui `SellerMembership` na Seller
   * possui papel `SellerRole.Owner`
5. Verificar se o Membership jÃ¡ existe (mesma Seller + User + Role)
6. Criar `SellerMembership`
7. Persistir via repositÃ³rio de escrita
8. Commit da Unit of Work
9. Retornar `SellerMembershipId`

---

### 3.3. RepositÃ³rios envolvidos (write model)

* `ISellerRepository`
* `IUserRepository`
* `ISellerMembershipRepository`

---

## 4. Validator `GrantSellerMembershipValidator`

### 4.1. Objetivo

Validar **entrada de dados**, nÃ£o regras de autorizaÃ§Ã£o.

---

### 4.2. Regras mÃ­nimas

* `SellerId` â‰  vazio
* `UserId` â‰  vazio
* `Role` deve ser um valor vÃ¡lido de `SellerRole`

---

## 5. AutorizaÃ§Ã£o (Regra de NegÃ³cio ExplÃ­cita)

âš ï¸ **Regra central do F2.3:**

> Apenas um **User com SellerRole.Owner** pode conceder Memberships em uma Seller.

Essa regra:

* **nÃ£o** fica no Domain
* **nÃ£o** fica na API
* Ã© aplicada no **Application Layer**, usando dados de Membership

---

## 6. Endpoint HTTP

### 6.1. Rota

```text
POST /api/sellers/{sellerId}/memberships
```

---

### 6.2. Request HTTP

```text
GrantSellerMembershipHttpRequest
```

Campos:

* `UserId`
* `Role`

---

### 6.3. Response HTTP

Retorno em caso de sucesso:

* `201 Created`
* `SellerMembershipId`

Erros esperados:

* `400` â€” validaÃ§Ã£o
* `401` â€” nÃ£o autenticado
* `403` â€” User autenticado nÃ£o Ã© Owner da Seller
* `404` â€” Seller ou User nÃ£o encontrados
* `409` â€” Membership jÃ¡ existente

---

## 7. Evento de DomÃ­nio envolvido

Evento **jÃ¡ existente e normativo**:

```text
SellerMembershipGranted
```

Payload mÃ­nimo:

* SellerId
* UserId
* Role

âš ï¸ Nenhum evento novo Ã© criado no F2.3.

---

## 8. Regras explÃ­citas do F2.3

1. Apenas Aggregates levantam eventos
2. `SellerMembership` Ã© o Ãºnico Aggregate modificado
3. AutorizaÃ§Ã£o Ã© baseada em **Membership + Role**
4. JWT **nÃ£o carrega papÃ©is**
5. PersistÃªncia apenas via write model
6. Queries de apoio (se existirem) usam Dapper (fora do escopo)

---

## 9. ObservaÃ§Ãµes de GovernanÃ§a

* F2.3 **introduz autorizaÃ§Ã£o real baseada em domÃ­nio**
* Ele valida, na prÃ¡tica, o conceito de Membership definido na Linguagem UbÃ­qua
* Serve como base direta para:

  * F2.4 â€” GrantFarmMembership
  * AutorizaÃ§Ã£o em Products, Orders, CollectiveDeals

---

## 10. PrÃ³ximo passo sugerido

Seguindo o Roadmap:

> **F2.4 â€” GrantFarmMembership**

Ou, se preferir:

> Criar o **prompt do Codex para F2.3**, seguindo exatamente este documento

Quando quiser, sigo imediatamente para qualquer um dos dois.
