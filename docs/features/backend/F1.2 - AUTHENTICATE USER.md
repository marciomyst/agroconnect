# ğŸ§© F1.2 â€” AuthenticateUser

## ğŸ¯ Objetivo

Permitir que um usuÃ¡rio previamente registrado faÃ§a **login** no sistema usando:

* `Email`
* `Password`

O resultado deve ser:

* credenciais validadas
* geraÃ§Ã£o de **JWT** assinado pela aplicaÃ§Ã£o
* devoluÃ§Ã£o de um **access token** (e opcionalmente refresh token, se vocÃª decidir usar)

ApÃ³s F1.2:

> o sistema suporta autenticaÃ§Ã£o baseada em JWT, pronta para proteger endpoints e carregar a identidade do `User`.

---

## âœ… Escopo

### Inclui

* Fluxo de autenticaÃ§Ã£o por email + senha
* VerificaÃ§Ã£o de credenciais usando `IUserRepository` + `IPasswordHasher`
* GeraÃ§Ã£o de **JWT** com:

  * `sub` = UserId
  * `email`
  * `iat`, `exp`
* ConfiguraÃ§Ã£o bÃ¡sica de **JWT Bearer** no `Agronomia.Api`
* Endpoint HTTP de login
* Tipos de erro adequados (401/400)

### NÃ£o inclui

* Registro de usuÃ¡rio (feito no F1.1)
* Refresh token / logout (pode ser F1.3)
* Roles, permissions, memberships (vem depois)
* Lockout, MFA, tentativas mÃºltiplas, etc. (futuro)

---

## ğŸ§  DecisÃµes arquiteturais (nÃ£o-negociÃ¡veis)

1. AutenticaÃ§Ã£o Ã© feita sobre o **User** criado em F1.1.
2. Senha **nunca** Ã© comparada em plaintext; sempre via `IPasswordHasher`.
3. O domÃ­nio **nÃ£o** conhece JWT.
4. O JWT Ã© responsabilidade da **camada de Application/Infra**.
5. A API usa **JWT Bearer** padrÃ£o para autenticaÃ§Ã£o de requests.

---

## ğŸ“ Estrutura de pastas (Vertical Slice)

### Application

```text
Agronomia.Application
 â””â”€â”€ Features
     â””â”€â”€ Identity
         â””â”€â”€ AuthenticateUser
             â”œâ”€â”€ AuthenticateUserCommand.cs
             â”œâ”€â”€ AuthenticateUserResult.cs
             â”œâ”€â”€ AuthenticateUserValidator.cs
             â””â”€â”€ AuthenticateUserHandler.cs
```

### Api

```text
Agronomia.Api
 â””â”€â”€ Features
     â””â”€â”€ Auth
         â””â”€â”€ Authenticate
             â”œâ”€â”€ AuthenticateUserEndpoint.cs
             â”œâ”€â”€ AuthenticateUserHttpRequest.cs
             â””â”€â”€ AuthenticateUserHttpResponse.cs
```

### Infrastructure

```text
Agronomia.Infrastructure
 â””â”€â”€ Auth
     â”œâ”€â”€ IJwtTokenGenerator.cs
     â””â”€â”€ JwtTokenGenerator.cs
```

*(A interface `IJwtTokenGenerator` pode ficar em `Application.Abstractions.Auth` se vocÃª quiser mais limpeza.)*

---

## 1ï¸âƒ£ Application â€” `AuthenticateUser` Command

### 1.1. Command

`AuthenticateUserCommand : ICommand<AuthenticateUserResult>`

Campos:

* `string Email`
* `string Password`

---

### 1.2. Result

`AuthenticateUserResult`:

* `Guid UserId`
* `string Email`
* `string AccessToken`
* (opcional futuro) `string? RefreshToken`
* (opcional) `DateTime ExpiresAtUtc`

---

### 1.3. Validator (FluentValidation)

`AuthenticateUserValidator`:

* `Email` obrigatÃ³rio e formato vÃ¡lido
* `Password` nÃ£o vazia

---

### 1.4. Handler

`AuthenticateUserCommandHandler : ICommandHandler<AuthenticateUserCommand, AuthenticateUserResult>`

**Responsabilidades (em ordem):**

1. Normalizar `Email` (trim + lowercase).
2. Buscar usuÃ¡rio por email via `IUserRepository.GetByEmailAsync`.

   * Se nÃ£o encontrar â†’ falha de autenticaÃ§Ã£o (401).
3. Usar `IPasswordHasher` para verificar se a senha estÃ¡ correta.

   * Se invÃ¡lida â†’ falha de autenticaÃ§Ã£o (401).
4. Invocar `IJwtTokenGenerator` para gerar o access token com:

   * `sub` = UserId
   * `email` = Email
   * `iat`, `exp`, etc.
5. Retornar `AuthenticateUserResult` com token.

**DependÃªncias:**

* `IUserRepository` (jÃ¡ existente do F1.1)
* `IPasswordHasher` (mesmo usado em F1.1)
* `IJwtTokenGenerator` (novo)

**Obs.:**
Erros de autenticaÃ§Ã£o devem ser padronizados (ex.: nÃ£o revelar se o email existe ou nÃ£o).

---

## 2ï¸âƒ£ Infrastructure â€” JWT

### 2.1. Interface `IJwtTokenGenerator`

Idealmente em `Agronomia.Application.Abstractions.Auth`:

```csharp
public interface IJwtTokenGenerator
{
    string GenerateToken(Guid userId, string email);
}
```

VocÃª pode expandir depois com claims adicionais, roles, etc.

---

### 2.2. ImplementaÃ§Ã£o `JwtTokenGenerator`

Em `Agronomia.Infrastructure.Auth`:

* Usa `IConfiguration` para:

  * secret key (HMAC)
  * issuer
  * audience
  * expiration (ex.: 60 minutos)
* Gera `JwtSecurityToken` e serializa para string.

**Regras:**

* Secret key **nÃ£o** hardcoded no cÃ³digo.
* Usar HMAC-SHA256 / HS256 como algoritmo padrÃ£o.
* ExpiraÃ§Ã£o finita (sem tokens eternos).

---

## 3ï¸âƒ£ API â€” Endpoint HTTP

### 3.1. Endpoint

`POST /api/auth/login` (ou `/api/auth/authenticate`)

### 3.2. Request DTO

`AuthenticateUserHttpRequest`:

* `string Email`
* `string Password`

---

### 3.3. Response DTO

`AuthenticateUserHttpResponse`:

* `Guid UserId`
* `string Email`
* `string AccessToken`
* (opcional) `DateTime ExpiresAtUtc`

---

### 3.4. Comportamento

* Mapear request â†’ `AuthenticateUserCommand`.
* Enviar via pipeline CQRS/Wolverine.
* Mapear result â†’ response.

CÃ³digos de status:

* `200 OK` â†’ sucesso
* `400 Bad Request` â†’ request invÃ¡lido (ex.: email vazio, formato invÃ¡lido)
* `401 Unauthorized` â†’ credenciais invÃ¡lidas (email nÃ£o encontrado ou senha errada)

**Nunca** devolver se o email existe ou nÃ£o em mensagens de erro.

---

## 4ï¸âƒ£ ConfiguraÃ§Ã£o de AutenticaÃ§Ã£o JWT na API

No projeto `Agronomia.Api`:

* Registrar autenticaÃ§Ã£o JWT Bearer no `Program.cs`/`Startup`:

  * chave simÃ©trica
  * issuer
  * audience
* Configurar o `Authentication` + `Authorization` middleware.
* (Opcional) Proteger um endpoint de teste com `[Authorize]` para garantir que o token funciona.

---

## 5ï¸âƒ£ CritÃ©rios de Aceite

F1.2 estÃ¡ pronto quando:

* [ ] UsuÃ¡rio com credenciais corretas recebe JWT vÃ¡lido.
* [ ] UsuÃ¡rio com email inexistente recebe 401.
* [ ] UsuÃ¡rio com senha errada recebe 401.
* [ ] Senha nunca aparece em logs nem responses.
* [ ] JWT inclui pelo menos `sub` (UserId), `email`, `iat`, `exp`.
* [ ] ConfiguraÃ§Ã£o de JWT Bearer permite autenticar endpoints com `[Authorize]`.

---

## 6ï¸âƒ£ Testes recomendados

### Application

* Handler retorna sucesso com token quando credenciais sÃ£o vÃ¡lidas.
* Handler retorna erro quando email nÃ£o existe.
* Handler retorna erro quando senha nÃ£o confere.

### Infra (pode ser teste de integraÃ§Ã£o ou unitÃ¡rio leve)

* `JwtTokenGenerator.GenerateToken` gera token decodificÃ¡vel com as claims esperadas.
* ExpiraÃ§Ã£o estÃ¡ correta (ex.: ~X minutos Ã  frente).

---

## Resultado esperado

Depois de F1.2:

* O sistema possui **registro** (F1.1) e **login** (F1.2) funcionando.
* A infraestrutura de CQRS + PersistÃªncia + JWT estÃ¡ exercitada fim a fim.
* VocÃª pode comeÃ§ar a:

  * proteger endpoints com `[Authorize]`,
  * e depois evoluir pra membership, roles e autorizaÃ§Ã£o contextual.