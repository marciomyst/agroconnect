# üß© F1.1 ‚Äî HTTP Interceptors & Global Error Handling

## üéØ Objetivo

Centralizar o tratamento de **autentica√ß√£o, contexto organizacional e erros HTTP**, garantindo comportamento consistente em toda a aplica√ß√£o e evitando duplica√ß√£o de l√≥gica de erro nos componentes.

---

## üß† Contexto Atual

J√° existe:

* `AuthTokenInterceptor`:

  * adiciona `Authorization: Bearer <token>`
  * adiciona `X-Organization-Id` ap√≥s F0.4
* Stores:

  * `AuthTokenService`
  * `CurrentUserStore`
  * `ActiveOrganizationStore`

Ainda n√£o existe:

* um **interceptor dedicado** para tratamento global de erros HTTP
* um contrato padr√£o para **normaliza√ß√£o de erros de valida√ß√£o** (400/422)

---

## üìå Escopo Detalhado

1. **Criar interceptor de erros HTTP**

   * Arquivo: `src/app/core/http/error-handling.interceptor.ts`
   * Tipo: `HttpInterceptorFn`
   * Respons√°vel por:

     * interceptar erros de todas as chamadas `/api/**`
     * aplicar estrat√©gia padr√£o para 401, 403, 400/422 e erros gen√©ricos (5xx, rede)

2. **Tratamento para 401 (Unauthorized)**

   * A√ß√µes:

     * limpar token via `AuthTokenService.clearToken()`
     * limpar estado de usu√°rio em `CurrentUserStore`
     * limpar organiza√ß√£o ativa em `ActiveOrganizationStore`
     * redirecionar para `/login` **apenas se a navega√ß√£o atual n√£o estiver j√° em rota p√∫blica**
   * Justificativa:

     * evitar loops de redirect
     * garantir que sess√£o inv√°lida seja encerrada de forma limpa

3. **Tratamento para 403 (Forbidden)**

   * A√ß√µes:

     * manter usu√°rio logado
     * op√ß√£o A: redirecionar para uma rota `/access-denied`
     * op√ß√£o B: lan√ßar erro padronizado para que componentes exibam mensagem espec√≠fica
   * Decis√£o recomendada:

     * utilizar um **servi√ßo de notifica√ß√£o** (a ser adicionado posteriormente) ou lan√ßar um erro com shape padronizado, ex.:

       ```ts
       throw createHttpError({
         status: 403,
         code: 'ACCESS_DENIED',
         message: 'Voc√™ n√£o tem permiss√£o para acessar este recurso.'
       });
       ```

4. **Tratamento para 400 / 422 (Validation / Business Errors)**

   * Normalizar erros de valida√ß√£o em um formato previs√≠vel, por exemplo:

     ```ts
     interface NormalizedValidationError {
       status: number;
       code?: string;
       message: string;
       fieldErrors?: Record<string, string[]>;
     }
     ```
   * Extrair do payload do backend (ex.: `errors`, `fieldErrors`, `notifications`) e converter para `NormalizedValidationError`.
   * Repassar o erro normalizado para o componente (via `throwError`) para que os forms possam mapear `fieldErrors`.

5. **Tratamento para erros gen√©ricos (5xx, rede)**

   * A√ß√µes:

     * mapear para um erro com `message` gen√©rica amig√°vel
     * ex.: "Ocorreu um erro ao processar sua requisi√ß√£o. Tente novamente em instantes."
   * N√£o redirecionar automaticamente, apenas normalizar o erro.

6. **N√£o acoplar UI diretamente ao interceptor**

   * O interceptor **n√£o deve** chamar diretamente componentes de UI ou servi√ßos de toast.
   * Apenas normalizar e direcionar (no caso de 401, redirect controlado).

---

## üåä Fluxo de Execu√ß√£o (Sequ√™ncia)

1. Componente chama `this.httpClient.get('/api/...')`.
2. `AuthTokenInterceptor` adiciona token + headers de organiza√ß√£o.
3. `ErrorHandlingInterceptor` recebe a resposta:

   * se sucesso ‚Üí repassa normalmente.
   * se erro HTTP ‚Üí aplica a l√≥gica:

     * 401 ‚Üí clear + redirect + erro normalizado.
     * 403 ‚Üí erro `ACCESS_DENIED`.
     * 400/422 ‚Üí `NormalizedValidationError`.
     * 5xx ‚Üí erro gen√©rico.
4. Componente recebe o erro j√° padronizado e decide como exibir.

---

## ‚úÖ Crit√©rios de Aceite (mais espec√≠ficos)

**Sess√£o / Seguran√ßa**

* [ ] Qualquer resposta **401** em `/api/**` resulta em:

  * [ ] `AuthTokenService.clearToken()` chamado exatamente 1 vez por ocorr√™ncia.
  * [ ] `CurrentUserStore` limpo (ex.: `clear()` ou equivalente) e `isAuthenticated` passa a `false`.
  * [ ] `ActiveOrganizationStore` limpo (`activeOrganization = null`).
  * [ ] Redirecionamento **√∫nico** para `/login` (sem loop e sem m√∫ltiplas navega√ß√µes concorrentes).
  * [ ] A URL final √© `/login` (n√£o fica ‚Äúpreso‚Äù em rota antiga).

**Acesso negado**

* [ ] Respostas **403**:

  * [ ] N√£o limpam token nem stores.
  * [ ] Retornam erro normalizado com `status: 403` e `code: 'ACCESS_DENIED'` (ou equivalente).
  * [ ] Permitem que a UI exiba uma mensagem amig√°vel (sem stack trace).

**Valida√ß√£o**

* [ ] Respostas **400/422**:

  * [ ] S√£o convertidas para um objeto normalizado com `message` e `fieldErrors`.
  * [ ] `fieldErrors` suporta m√∫ltiplas mensagens por campo (`Record<string, string[]>`).
  * [ ] Campos desconhecidos (n√£o mape√°veis) n√£o quebram o app; caem em erro global.

**Erros gen√©ricos**

* [ ] Respostas **5xx** e erros de rede:

  * [ ] Produzem mensagem gen√©rica amig√°vel.
  * [ ] N√£o exp√µem detalhes internos do backend.
  * [ ] N√£o fazem redirect autom√°tico.

**Compatibilidade / N√£o regress√£o**

* [ ] Rotas p√∫blicas e bootstrap (ex.: `/api/auth/login`, `/api/auth/me`) continuam funcionando.
* [ ] Componentes n√£o precisam ter `if (status === 401)` para encerrar sess√£o.
* [ ] Ordem dos interceptors √© consistente: token/contexto antes, erro depois.

**Verifica√ß√£o manual m√≠nima**

* [ ] Com token inv√°lido, acessar uma rota protegida ‚Üí redireciona para `/login` e limpa stores.
* [ ] Com role insuficiente em endpoint protegido ‚Üí recebe 403 e UI mostra ‚Äúacesso negado‚Äù.