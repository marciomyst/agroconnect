# ğŸ§© F0.2 â€” Auth & CurrentUserContext Store

## ğŸ¯ Objetivo

Implementar a **fundaÃ§Ã£o de autenticaÃ§Ã£o do frontend** e o **contexto de usuÃ¡rio logado**, permitindo que o sistema:

* Autentique usuÃ¡rios via backend
* Armazene e propague o JWT
* Carregue o contexto completo do usuÃ¡rio (`CurrentUserContext`)
* Proteja rotas por autenticaÃ§Ã£o e papel (role)
* ForneÃ§a uma base reutilizÃ¡vel para todas as Ã¡reas do sistema

Este F0.2 **nÃ£o entrega funcionalidades de negÃ³cio**, apenas a **infraestrutura mÃ­nima** para que elas existam com seguranÃ§a e previsibilidade.

---

## ğŸ§­ MotivaÃ§Ã£o

Com o **F-Front 0.1** concluÃ­do, o frontend jÃ¡ possui:

* Arquitetura de rotas estÃ¡vel
* SeparaÃ§Ã£o clara entre Public / Farmer / Seller / Admin
* Controle de acesso por `canMatch`

Entretanto, os guards ainda sÃ£o **estruturais (stubs)**.
Sem autenticaÃ§Ã£o real e sem um contexto de usuÃ¡rio carregado do backend:

* NÃ£o Ã© possÃ­vel proteger corretamente as rotas
* NÃ£o Ã© possÃ­vel saber a qual Farmer/Seller o usuÃ¡rio pertence
* O frontend nÃ£o consegue refletir regras de Membership e Role

O F-Front 0.2 resolve isso ao introduzir **Auth + CurrentUserContext** como infraestrutura central.

---

## ğŸ“Œ Escopo

### Inclui

* ServiÃ§o de autenticaÃ§Ã£o (login)
* Armazenamento e gerenciamento do JWT
* Interceptor HTTP para autorizaÃ§Ã£o
* Carregamento do contexto do usuÃ¡rio (`/api/auth/me`)
* Store de usuÃ¡rio baseada em **Angular Signals**
* Guards funcionais (`authCanMatch`, `roleCanMatch`)
* IntegraÃ§Ã£o mÃ­nima com o fluxo de login pÃºblico

### NÃ£o inclui

* Registro de usuÃ¡rio
* RecuperaÃ§Ã£o de senha
* SeleÃ§Ã£o de organizaÃ§Ã£o ativa
* UI final de login
* Funcionalidades de marketplace, farmer ou seller

---

## ğŸ” AutenticaÃ§Ã£o

### Endpoint de Login

O frontend deve integrar-se ao backend:

```http
POST /api/auth/login
```

Responsabilidades do frontend:

* Enviar credenciais (`email`, `password`)
* Receber o JWT
* Persistir o token
* Iniciar o carregamento do contexto do usuÃ¡rio

---

## ğŸ§© CurrentUserContext

### Fonte de Verdade

O contexto do usuÃ¡rio deve ser obtido exclusivamente via:

```http
GET /api/auth/me
```

Este endpoint retorna:

* Identidade do usuÃ¡rio
* OrganizaÃ§Ãµes (Farms / Sellers)
* PapÃ©is (Roles) exercidos em cada organizaÃ§Ã£o

O frontend **nÃ£o deve inferir roles localmente**.

---

## ğŸ§  CurrentUserStore (Signals)

### Responsabilidade

Centralizar o estado do usuÃ¡rio autenticado, incluindo:

* Dados do usuÃ¡rio
* Lista de organizaÃ§Ãµes
* PapÃ©is associados
* Estado de autenticaÃ§Ã£o

### CaracterÃ­sticas

* Implementado com **Angular Signals**
* NÃ£o depende de componentes
* Pode ser consumido por:

  * Guards
  * Layouts
  * Componentes
  * Futuro seletor de organizaÃ§Ã£o

### OperaÃ§Ãµes mÃ­nimas

* `setUser(context | null)`
* `clear()`
* `loadFromApi()`

---

## ğŸ”‘ Token Management

### AuthTokenService

ResponsÃ¡vel exclusivamente por:

* Salvar o token
* Ler o token atual
* Remover o token (logout)
* Informar se existe token vÃ¡lido

> Token â‰  Contexto de UsuÃ¡rio
> SÃ£o responsabilidades distintas.

---

## ğŸŒ HTTP Interceptor

### AuthTokenInterceptor

FunÃ§Ã£o:

* Anexar `Authorization: Bearer <token>` em requisiÃ§Ãµes autenticadas
* NÃ£o bloquear requisiÃ§Ãµes pÃºblicas
* Ser transparente para chamadas sem token

---

## ğŸš¦ Guards Funcionais

### authCanMatch

ResponsÃ¡vel por:

* Verificar se existe token
* Garantir que o `CurrentUserContext` esteja carregado
* Bloquear rotas protegidas se o usuÃ¡rio nÃ£o estiver autenticado

### roleCanMatch(role)

ResponsÃ¡vel por:

* Verificar se o usuÃ¡rio possui o papel exigido
* AvaliaÃ§Ã£o baseada em **membership**, nÃ£o em role global
* Permitir acesso se o papel existir em qualquer organizaÃ§Ã£o

> O conceito de â€œorganizaÃ§Ã£o ativaâ€ **nÃ£o Ã© tratado neste F0.2**.

---

## ğŸ”Œ IntegraÃ§Ã£o com o MÃ³dulo PÃºblico

O fluxo de login pÃºblico deve:

1. Enviar credenciais para o backend
2. Armazenar o token
3. Carregar o `CurrentUserContext`
4. Atualizar o estado global do frontend
5. Permitir acesso Ã s rotas protegidas

A UI pode ser simples ou provisÃ³ria.
O foco Ã© **infraestrutura funcional**, nÃ£o experiÃªncia final.

---

## ğŸ—‚ï¸ Estrutura de Arquivos (ReferÃªncia)

```text
src/app/core/
 â”œâ”€â”€ auth/
 â”‚    â”œâ”€â”€ auth-api.service.ts
 â”‚    â”œâ”€â”€ auth-token.service.ts
 â”‚    â”œâ”€â”€ auth-token.interceptor.ts
 â”‚    â”œâ”€â”€ current-user.store.ts
 â”‚    â””â”€â”€ guards/
 â”‚         â”œâ”€â”€ auth.can-match.ts
 â”‚         â””â”€â”€ role.can-match.ts
```

---

## ğŸ“ Regras Arquiteturais

1. Guards nunca chamam API diretamente
2. Componentes nunca gerenciam token
3. Store nÃ£o conhece UI
4. Interceptor nÃ£o conhece domÃ­nio
5. Toda informaÃ§Ã£o de papel vem do backend
6. Public / Farmer / Seller / Admin consomem o mesmo contexto

---

## ğŸš« Fora de Escopo

* Registro de usuÃ¡rios
* Fluxos de senha
* OrganizaÃ§Ã£o ativa
* AutorizaÃ§Ã£o por feature interna
* Cache avanÃ§ado ou refresh token

---

## âœ… Checklist de ImplementaÃ§Ã£o

### Core

* [ ] AuthApiService
* [ ] AuthTokenService
* [ ] AuthTokenInterceptor
* [ ] CurrentUserStore (Signals)

### Guards

* [ ] authCanMatch funcional
* [ ] roleCanMatch funcional

### Public

* [ ] Login mÃ­nimo integrado
* [ ] Fluxo end-to-end validado