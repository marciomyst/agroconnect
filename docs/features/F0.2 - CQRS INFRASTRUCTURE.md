# ğŸ§± F0.2 â€” CQRS Infrastructure (Wolverine)

## ğŸ¯ Objetivo

Estabelecer a **infraestrutura padrÃ£o de execuÃ§Ã£o de Commands, Queries e Events**, garantindo que:

* todo write siga CQRS de forma consistente
* todo fluxo tenha pipeline previsÃ­vel (validaÃ§Ã£o, logging, transaÃ§Ãµes)
* o domÃ­nio permaneÃ§a **agnÃ³stico de infraestrutura**
* Wolverine seja usado como **meio**, nÃ£o como acoplamento

Depois do F0.2:

> Nenhuma feature pode criar handlers â€œad hocâ€.
> Tudo passa pelo pipeline definido aqui.

---

## ğŸ“Œ Escopo do F0.2

### O que F0.2 **faz**

* Configura Wolverine como:

  * dispatcher de Commands
  * executor de Queries
  * roteador de Events
* Define **contratos base** de CQRS
* Define **pipeline transversal**
* Integra com DI e ASP.NET Core

### O que F0.2 **nÃ£o faz**

* NÃ£o cria nenhuma feature de negÃ³cio
* NÃ£o cria agregados
* NÃ£o cria eventos concretos
* NÃ£o cria endpoints especÃ­ficos

---

## ğŸ§  DecisÃ£o arquitetural central

> **CQRS Ã© um padrÃ£o da aplicaÃ§Ã£o, nÃ£o do domÃ­nio.**

* O domÃ­nio **nÃ£o conhece** Wolverine
* O domÃ­nio **nÃ£o conhece** Commands ou Queries
* O domÃ­nio sÃ³ conhece:

  * mÃ©todos
  * invariantes
  * Domain Events

Wolverine vive em:

* `Application`
* `Infrastructure`
* `Api` (integraÃ§Ã£o HTTP)

---

## ğŸ“ Estrutura de pastas introduzida / consolidada

```text
Agronomia.Application
 â”œâ”€â”€ Abstractions
 â”‚   â”œâ”€â”€ CQRS
 â”‚   â”‚   â”œâ”€â”€ ICommand.cs
 â”‚   â”‚   â”œâ”€â”€ IQuery.cs
 â”‚   â”‚   â”œâ”€â”€ ICommandHandler.cs
 â”‚   â”‚   â””â”€â”€ IQueryHandler.cs
 â”‚   â””â”€â”€ Messaging
 â”‚       â””â”€â”€ IEventDispatcher.cs
 â”‚
 â”œâ”€â”€ Behaviors
 â”‚   â”œâ”€â”€ ValidationBehavior.cs
 â”‚   â”œâ”€â”€ LoggingBehavior.cs
 â”‚   â””â”€â”€ TransactionBehavior.cs
 â”‚
 â””â”€â”€ Infrastructure
     â””â”€â”€ Wolverine
         â”œâ”€â”€ WolverineExtensions.cs
         â””â”€â”€ WolverineConventions.cs
```

*(nomes podem variar, mas responsabilidades nÃ£o)*

---

## 1ï¸âƒ£ Contratos base de CQRS (Application)

### 1.1. Commands

```csharp
public interface ICommand<TResult> { }
```

* Representam **intenÃ§Ã£o de mudanÃ§a**
* Executados exatamente uma vez
* Podem levantar Domain Events

---

### 1.2. Command Handlers

```csharp
public interface ICommandHandler<TCommand, TResult>
    where TCommand : ICommand<TResult>
{
    Task<TResult> HandleAsync(TCommand command, CancellationToken ct);
}
```

Regras:

* Um handler por command
* Sem lÃ³gica HTTP
* Sem acesso direto a Dapper
* Orquestra agregados e repositÃ³rios

---

### 1.3. Queries

```csharp
public interface IQuery<TResult> { }
```

* **Nunca** alteram estado
* **Nunca** levantam Domain Events
* Sempre retornam DTOs

---

### 1.4. Query Handlers

```csharp
public interface IQueryHandler<TQuery, TResult>
    where TQuery : IQuery<TResult>
{
    Task<TResult> HandleAsync(TQuery query, CancellationToken ct);
}
```

Regras:

* Usam Dapper
* NÃ£o retornam Aggregates
* NÃ£o participam de transaÃ§Ãµes de escrita

---

## 2ï¸âƒ£ Pipeline transversal (Behaviors)

Esses behaviors garantem **consistÃªncia nÃ£o-funcional**.

### 2.1. ValidationBehavior

ResponsÃ¡vel por:

* executar FluentValidation
* bloquear execuÃ§Ã£o invÃ¡lida antes do handler

Fluxo:

```
Request â†’ Validation â†’ Handler
```

---

### 2.2. LoggingBehavior

ResponsÃ¡vel por:

* logar inÃ­cio/fim de execuÃ§Ã£o
* correlacionar requests
* medir tempo de execuÃ§Ã£o

Sem:

* logar dados sensÃ­veis
* logar payloads grandes

---

### 2.3. TransactionBehavior (Commands apenas)

ResponsÃ¡vel por:

* abrir transaÃ§Ã£o
* executar handler
* persistir agregados
* despachar Domain Events
* commit / rollback

Fluxo real:

```
Command
 â†’ Begin Transaction
 â†’ Handler
 â†’ Persist Aggregates
 â†’ Dispatch Domain Events
 â†’ Commit
```

ğŸ“Œ Queries **nÃ£o passam** por esse behavior.

---

## 3ï¸âƒ£ IntegraÃ§Ã£o com Wolverine

### 3.1. Papel do Wolverine

Wolverine Ã© usado como:

* dispatcher de mensagens
* runtime de handlers
* integraÃ§Ã£o sÃ­ncrona e futura assÃ­ncrona

Ele **nÃ£o**:

* define o domÃ­nio
* define contratos de negÃ³cio
* define nomenclatura

---

### 3.2. Mapeamento de Handlers

* `ICommandHandler<T, R>` â†’ Wolverine Message Handler
* `IQueryHandler<T, R>` â†’ Wolverine Message Handler
* Domain Events â†’ Wolverine messages (infra)

Isso pode ser feito por:

* adaptaÃ§Ã£o direta
* ou conventions no bootstrap

---

### 3.3. Dispatch de Domain Events

Regra clara:

> Domain Events sÃ£o **levantados no domÃ­nio**,
> mas **publicados fora dele**.

Fluxo:

1. Aggregate levanta evento
2. Application coleta eventos
3. Infrastructure publica via Wolverine
4. Aggregate limpa eventos

---

## 4ï¸âƒ£ IntegraÃ§Ã£o com API (HTTP)

### Controllers / Endpoints

* Endpoint:

  * recebe HTTP Request
  * mapeia para Command ou Query
  * envia para Wolverine
  * retorna Response

Nenhuma lÃ³gica alÃ©m disso.

Exemplo mental:

```
HTTP POST
 â†’ Map Request â†’ Command
 â†’ Wolverine.Invoke(command)
 â†’ Return Result
```

---

## 5ï¸âƒ£ Regras de ouro do F0.2

Essas regras **nÃ£o podem ser quebradas depois**:

1. **Nenhum handler fora do pipeline**
2. **Commands â‰  Queries**
3. **Queries nunca usam EF Core**
4. **Commands nunca retornam Aggregates**
5. **DomÃ­nio nÃ£o conhece Wolverine**
6. **Events sÃ³ saem do domÃ­nio via Application/Infrastructure**

---

## 6ï¸âƒ£ CritÃ©rios de aceite do F0.2

F0.2 estÃ¡ completo quando:

* [ ] Commands e Queries tÃªm contratos base
* [ ] Wolverine estÃ¡ configurado e funcionando
* [ ] Existe pipeline com:

  * validaÃ§Ã£o
  * logging
  * transaÃ§Ã£o (commands)
* [ ] Ã‰ possÃ­vel executar:

  * um Command â€œdummyâ€
  * uma Query â€œdummyâ€
* [ ] Domain Events podem ser levantados e despachados
