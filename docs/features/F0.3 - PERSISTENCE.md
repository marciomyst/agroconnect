# ğŸ§± F0.3 â€” PersistÃªncia Base (Write Model + Read Model)

## ğŸ¯ Objetivo

Estabelecer a **infraestrutura mÃ­nima e definitiva de persistÃªncia** do sistema, garantindo que:

* **Commands (write model)** persistam Aggregates via **EF Core**
* **Queries (read model)** usem **Dapper**, com foco em performance
* A separaÃ§Ã£o **CQRS (write â‰  read)** seja respeitada desde o inÃ­cio
* TransaÃ§Ãµes sejam coordenadas pelo **Application Layer** via `IUnitOfWork`
* O **DomÃ­nio permaneÃ§a 100% livre** de detalhes de persistÃªncia

ApÃ³s o F0.3:

> Qualquer feature de escrita pode persistir Aggregates com seguranÃ§a
> Qualquer feature de leitura pode consultar dados de forma otimizada

---

## ğŸ“Œ Escopo do F0.3

### Inclui

* DbContext base do sistema (write model)
* ConfiguraÃ§Ã£o EF Core e migrations
* AbstraÃ§Ã£o e implementaÃ§Ã£o de `IUnitOfWork`
* Infraestrutura de Dapper para read model
* ConfiguraÃ§Ã£o de DI para persistÃªncia
* IntegraÃ§Ã£o com o `TransactionBehavior` do F0.2

### NÃ£o inclui

* Features de negÃ³cio (Seller, Farm, Order, etc.)
* RepositÃ³rios concretos de domÃ­nio (apenas base/infra)
* Queries especÃ­ficas (DTOs de leitura)
* Outbox / Inbox (pode ser um F0.4 futuro)

---

## ğŸ§  DecisÃµes arquiteturais (nÃ£o-negociÃ¡veis)

1. **EF Core Ã© exclusivo do Write Model**

   * EF Core persiste **Aggregates**
   * EF Core **nÃ£o Ã© usado** por Queries

2. **Dapper Ã© exclusivo do Read Model**

   * Dapper retorna **DTOs**
   * Dapper **nÃ£o materializa Aggregates**

3. **Domain nÃ£o conhece persistÃªncia**

   * Nenhuma referÃªncia a EF Core, Dapper ou DbContext no Domain

4. **TransaÃ§Ãµes sÃ£o responsabilidade do Application**

   * Via `TransactionBehavior` + `IUnitOfWork`

---

## ğŸ“ Estrutura de pastas

```text
Agronomia.Infrastructure
 â”œâ”€â”€ Persistence
 â”‚   â”œâ”€â”€ AgronomiaDbContext.cs
 â”‚   â”œâ”€â”€ Migrations/
 â”‚   â”œâ”€â”€ Configurations/          # EF Core mappings
 â”‚   â””â”€â”€ Interceptors/            # reservado (auditoria/outbox futuro)
 â”‚
 â”œâ”€â”€ UnitOfWork
 â”‚   â””â”€â”€ EfUnitOfWork.cs
 â”‚
 â”œâ”€â”€ Dapper
 â”‚   â”œâ”€â”€ IDbConnectionFactory.cs
 â”‚   â””â”€â”€ DbConnectionFactory.cs
 â”‚
 â””â”€â”€ DependencyInjection
     â””â”€â”€ InfrastructureModule.cs
```

Interfaces compartilhadas ficam em:

```text
Agronomia.Application.Abstractions
 â””â”€â”€ Persistence
     â””â”€â”€ IUnitOfWork.cs
```

---

## 1ï¸âƒ£ Write Model â€” EF Core

### 1.1. `AgronomiaDbContext`

**Responsabilidade**

* Representar o contexto de escrita do sistema
* Persistir Aggregates
* Gerenciar transaÃ§Ãµes

**Requisitos**

* Herdar de `DbContext`
* Aplicar configuraÃ§Ãµes via `IEntityTypeConfiguration<>`
* NÃ£o conter lÃ³gica de domÃ­nio
* Ser preparado para futuros Aggregates

**ObservaÃ§Ã£o**
Mesmo que inicialmente nÃ£o existam entidades de negÃ³cio, o DbContext deve existir para:

* validar a infraestrutura
* habilitar migrations
* garantir que o pipeline esteja pronto

---

### 1.2. ConfiguraÃ§Ãµes EF Core

* Mapeamentos isolados em `Configurations`
* Escolher e fixar um padrÃ£o:

  * nomes de tabelas
  * nomes de colunas
  * convenÃ§Ã£o de chaves
* **NÃ£o usar Data Annotations no domÃ­nio**

---

### 1.3. Migrations

F0.3 deve garantir que:

* migrations estÃ£o habilitadas
* pipeline de build executa sem erros
* banco pode ser criado/atualizado

Mesmo que:

* a migration inicial esteja quase vazia

---

## 2ï¸âƒ£ TransaÃ§Ãµes â€” `IUnitOfWork`

### 2.1. Interface (`Application.Abstractions`)

```csharp
public interface IUnitOfWork
{
    Task BeginAsync(CancellationToken ct);
    Task CommitAsync(CancellationToken ct);
    Task RollbackAsync(CancellationToken ct);
}
```

**PrincÃ­pios**

* Simples
* TestÃ¡vel
* Independente de EF Core na interface

---

### 2.2. ImplementaÃ§Ã£o EF â€” `EfUnitOfWork`

**Responsabilidades**

* Abrir transaÃ§Ã£o no DbContext
* Commit
* Rollback
* Garantir dispose correto

**Regras**

* NÃ£o contÃ©m lÃ³gica de negÃ³cio
* NÃ£o conhece Commands ou Queries
* SÃ³ coordena persistÃªncia

---

### 2.3. IntegraÃ§Ã£o com F0.2

O `TransactionBehavior` (F0.2) deve:

```
BeginAsync
 â†’ executar handler
 â†’ CommitAsync
```

Em erro:

```
RollbackAsync
```

F0.3 deve **viabilizar esse fluxo**, nÃ£o executÃ¡-lo.

---

## 3ï¸âƒ£ Read Model â€” Dapper

### 3.1. `IDbConnectionFactory`

Interface em Infrastructure (ou Application.Abstractions, se preferir):

```csharp
public interface IDbConnectionFactory
{
    IDbConnection CreateConnection();
}
```

**Regras**

* Retorna conexÃ£o pronta para uso
* Usa `IConfiguration` para connection string
* NÃ£o executa queries
* NÃ£o faz cache de resultados

---

### 3.2. `DbConnectionFactory`

ImplementaÃ§Ã£o concreta:

* Define provider (ex.: SQL Server, PostgreSQL)
* Centraliza connection string
* Padroniza criaÃ§Ã£o de conexÃµes

---

### 3.3. Uso pelas Queries

* Queries:

  * recebem `IDbConnectionFactory`
  * criam conexÃ£o localmente
  * executam Dapper
  * retornam DTOs

**Nunca**

* Aggregates
* Entities do domÃ­nio

---

## 4ï¸âƒ£ ConfiguraÃ§Ã£o de DI

Em `InfrastructureModule` (ou similar):

Registrar:

* `AgronomiaDbContext`
* `IUnitOfWork` â†’ `EfUnitOfWork`
* `IDbConnectionFactory`

Separar claramente:

* infraestrutura
* aplicaÃ§Ã£o
* domÃ­nio

---

## 5ï¸âƒ£ ConfiguraÃ§Ã£o de ambiente

F0.3 define:

* `ConnectionStrings:Agronomia`
* `appsettings.json`
* `appsettings.Development.json`

**Regra**

* Sem segredos no repositÃ³rio
* Sem connection string hardcoded

---

## 6ï¸âƒ£ CritÃ©rios de Aceite (Definition of Done)

F0.3 estÃ¡ concluÃ­do quando:

* [ ] DbContext existe e estÃ¡ configurado
* [ ] Migrations funcionam
* [ ] `IUnitOfWork` existe (Application)
* [ ] `EfUnitOfWork` implementa transaÃ§Ã£o
* [ ] `TransactionBehavior` consegue usar `IUnitOfWork`
* [ ] `IDbConnectionFactory` cria conexÃµes
* [ ] Dapper pode ser usado em Queries
* [ ] Build sobe sem erro

---

## 7ï¸âƒ£ PreparaÃ§Ã£o para evoluÃ§Ã£o futura

F0.3 **nÃ£o implementa**, mas prepara o terreno para:

* Outbox Pattern
* Auditoria
* Versionamento de schema
* Read models mais complexos
