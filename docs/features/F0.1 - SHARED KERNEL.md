## üéØ Objetivo do F0.1 ‚Äî Shared Kernel

Criar o **n√∫cleo compartilhado de dom√≠nio** que ser√° usado por todos os Bounded Contexts:

* Identidade e igualdade de entidades
* Agregados e eventos de dom√≠nio
* Value Objects
* Resultado de opera√ß√µes de dom√≠nio (Result)
* Helpers de valida√ß√£o (Guard)

Sem depend√™ncia de:

* EF Core
* Wolverine
* Dapper
* Infraestrutura em geral

---

## üìÅ Estrutura de pastas / namespaces

Em `Agronomia.Domain`:

```text
Agronomia.Domain
 ‚îî‚îÄ‚îÄ Common
     ‚îú‚îÄ‚îÄ Entity.cs
     ‚îú‚îÄ‚îÄ AggregateRoot.cs
     ‚îú‚îÄ‚îÄ ValueObject.cs
     ‚îú‚îÄ‚îÄ DomainEvent.cs
     ‚îú‚îÄ‚îÄ IHasDomainEvents.cs
     ‚îú‚îÄ‚îÄ Result.cs
     ‚îî‚îÄ‚îÄ Guard.cs
```

Namespaces sugeridos:

```csharp
namespace Agronomia.Domain.Common;
```

---

## 1. `DomainEvent` e `IHasDomainEvents`

### 1.1. `DomainEvent` (record base)

**Objetivo:** base para todos os eventos de dom√≠nio.

**Requisitos:**

* Deve ser um `record` imut√°vel
* Deve ter:

  * `Guid EventId`
  * `DateTime OccurredAt` (UTC)

**Assinatura sugerida:**

```csharp
public abstract record DomainEvent(
    Guid EventId,
    DateTime OccurredAt
);
```

**Conven√ß√£o de uso:**

* Eventos concretos herdam de `DomainEvent`, por exemplo:

```csharp
public sealed record SellerRegistered(
    Guid EventId,
    DateTime OccurredAt,
    Guid SellerId,
    string TaxId,
    string CorporateName
) : DomainEvent(EventId, OccurredAt);
```

---

### 1.2. `IHasDomainEvents`

**Objetivo:** interface para tipos que acumulam eventos (normalmente Aggregates).

**Assinatura:**

```csharp
public interface IHasDomainEvents
{
    IReadOnlyCollection<DomainEvent> DomainEvents { get; }
    void ClearDomainEvents();
}
```

---

## 2. `Entity`

### 2.1. Objetivo

Base para todas as entidades do dom√≠nio (com identidade).

### 2.2. Requisitos

* Tipo abstrato
* Possui `Guid Id`
* Igualdade baseada em `Id`
* Protege construtor padr√£o (para EF / serializa√ß√£o, se necess√°rio)

**Assinatura sugerida:**

```csharp
public abstract class Entity
{
    public Guid Id { get; protected init; }

    protected Entity() { }

    protected Entity(Guid id)
    {
        Id = id;
    }

    protected bool Equals(Entity other)
        => Id.Equals(other.Id);

    public override bool Equals(object? obj)
    {
        if (obj is null) return false;
        if (ReferenceEquals(this, obj)) return true;
        if (obj.GetType() != GetType()) return false;
        return Equals((Entity)obj);
    }

    public override int GetHashCode() => Id.GetHashCode();

    public static bool operator ==(Entity? left, Entity? right)
        => Equals(left, right);

    public static bool operator !=(Entity? left, Entity? right)
        => !Equals(left, right);
}
```

---

## 3. `AggregateRoot`

### 3.1. Objetivo

Base para agregados que:

* exp√µem invariantes
* acumulam eventos de dom√≠nio

### 3.2. Requisitos

* Herdar de `Entity`
* Implementar `IHasDomainEvents`
* Manter lista privada de `DomainEvent`
* Expor `AddDomainEvent` e `ClearDomainEvents`

**Assinatura sugerida:**

```csharp
public abstract class AggregateRoot : Entity, IHasDomainEvents
{
    private readonly List<DomainEvent> _domainEvents = new();

    protected AggregateRoot() { }

    protected AggregateRoot(Guid id) : base(id) { }

    public IReadOnlyCollection<DomainEvent> DomainEvents => _domainEvents.AsReadOnly();

    protected void AddDomainEvent(DomainEvent domainEvent)
    {
        _domainEvents.Add(domainEvent);
    }

    public void ClearDomainEvents()
    {
        _domainEvents.Clear();
    }
}
```

**Regra de uso:**

* **Somente Aggregates** devem levantar eventos via `AddDomainEvent`.
* Entities internas **n√£o** acumulam eventos diretamente.

Exemplo:

```csharp
public sealed class Seller : AggregateRoot
{
    private Seller(Guid id, /* outros params */) : base(id)
    {
        // atribui√ß√µes...
    }

    public static Seller Register(/* params */)
    {
        var seller = new Seller(Guid.NewGuid(), /* params */);

        seller.AddDomainEvent(
            new SellerRegistered(
                Guid.NewGuid(),
                DateTime.UtcNow,
                seller.Id,
                /* TaxId, CorporateName... */
            ));

        return seller;
    }
}
```

---

## 4. `ValueObject`

### 4.1. Objetivo

Base para value objects:

* imut√°veis
* igualdade por valor (componentes)
* sem identidade

### 4.2. Requisitos

* Tipo abstrato
* Implementa Equals/GetHashCode baseado em componentes

**Assinatura sugerida:**

```csharp
public abstract class ValueObject
{
    protected abstract IEnumerable<object?> GetEqualityComponents();

    public override bool Equals(object? obj)
    {
        if (obj is null || obj.GetType() != GetType())
            return false;

        var other = (ValueObject)obj;

        return GetEqualityComponents()
            .SequenceEqual(other.GetEqualityComponents());
    }

    public override int GetHashCode()
    {
        return GetEqualityComponents()
            .Aggregate(0, (hash, obj) =>
            {
                unchecked
                {
                    return (hash * 397) ^ (obj?.GetHashCode() ?? 0);
                }
            });
    }

    public static bool operator ==(ValueObject? left, ValueObject? right)
        => Equals(left, right);

    public static bool operator !=(ValueObject? left, ValueObject? right)
        => !Equals(left, right);
}
```

**Exemplo de VO concreto:**

```csharp
public sealed class TaxId : ValueObject
{
    public string Value { get; }

    private TaxId(string value)
    {
        Value = value;
    }

    public static TaxId Create(string value)
    {
        // valida√ß√£o aqui...
        return new TaxId(value);
    }

    protected override IEnumerable<object?> GetEqualityComponents()
    {
        yield return Value;
    }

    public override string ToString() => Value;
}
```

---

## 5. `Result`

### 5.1. Objetivo

Representar resultado de opera√ß√µes de dom√≠nio/aplica√ß√£o:

* sucesso ou falha
* carregar erros de forma estruturada

### 5.2. Requisitos

* `Result` simples (sem payload)
* `Result<T>` com valor
* API fluente e simples

**Assinatura sugerida:**

```csharp
public class Result
{
    public bool IsSuccess { get; }
    public bool IsFailure => !IsSuccess;
    public string? Error { get; }

    protected Result(bool isSuccess, string? error)
    {
        IsSuccess = isSuccess;
        Error = error;
    }

    public static Result Success() => new(true, null);

    public static Result Failure(string error) => new(false, error);
}

public class Result<T> : Result
{
    public T? Value { get; }

    protected Result(bool isSuccess, T? value, string? error)
        : base(isSuccess, error)
    {
        Value = value;
    }

    public static Result<T> Success(T value) => new(true, value, null);

    public new static Result<T> Failure(string error) => new(false, default, error);
}
```

**Regra de uso:**

* Dentro de **dom√≠nio**, use `Result` apenas em factories ou opera√ß√µes mais complexas.
* Em casos simples, pode lan√ßar exce√ß√µes de dom√≠nio espec√≠ficas.

---

## 6. `Guard`

### 6.1. Objetivo

Helpers est√°ticos para valida√ß√£o defensiva.

### 6.2. Requisitos

* M√©todos est√°ticos
* Lan√ßam exce√ß√µes de dom√≠nio (que voc√™ vai definir depois) ou `ArgumentException` na base

**Assinatura sugerida:**

```csharp
public static class Guard
{
    public static void AgainstNull(object? value, string parameterName)
    {
        if (value is null)
            throw new ArgumentNullException(parameterName);
    }

    public static void AgainstNullOrEmpty(string? value, string parameterName)
    {
        if (string.IsNullOrWhiteSpace(value))
            throw new ArgumentException($"{parameterName} cannot be null or empty.", parameterName);
    }

    public static void AgainstNegativeOrZero(decimal value, string parameterName)
    {
        if (value <= 0)
            throw new ArgumentOutOfRangeException(parameterName, $"{parameterName} must be greater than zero.");
    }
}
```

Voc√™ pode evoluir depois para exce√ß√µes de dom√≠nio espec√≠ficas (`DomainException`), mas n√£o √© obrigat√≥rio agora.

---

## 7. Regras de uso do Shared Kernel

1. **Todos Aggregates** devem herdar de `AggregateRoot`.
2. **Todas Entities** com `Id` devem herdar de `Entity`.
3. Todos os Value Objects devem herdar de `ValueObject`.
4. Todos os eventos de dom√≠nio concretos devem herdar de `DomainEvent`.
5. **Nenhum c√≥digo de infra** (EF, Wolverine, Dapper) √© permitido em `Agronomia.Domain.Common`.
6. Shared Kernel **n√£o referencia** Application, Api, Infrastructure.

---

## 8. Instru√ß√µes para o GPT-5.2-Codex (se voc√™ quiser automatizar)

Quando for pedir pro Codex gerar o Shared Kernel, use algo assim:

```text
You are implementing the F0.1 ‚Äî Shared Kernel for the Agronomia backend (.NET 10).

Follow these constraints:
- Project: Agronomia.Domain
- Namespace: Agronomia.Domain.Common
- No external dependencies (no EF Core, no Wolverine, no Dapper)
- Implement: Entity, AggregateRoot, ValueObject, DomainEvent, IHasDomainEvents, Result, Result<T>, Guard

Requirements:
- Entities compare by Id
- AggregateRoot holds DomainEvents
- ValueObject compares by equality components
- DomainEvent has EventId (Guid) and OccurredAt (UTC)
- Result/Result<T> represent success/failure
- Guard methods throw exceptions on invalid arguments

Return:
- One file per class, with full code
- No extra commentary
```